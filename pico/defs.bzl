load("@rules_cc//cc:toolchain_utils.bzl", "find_cpp_toolchain")

WRAP_FUNCTIONS = [
        "__aeabi_cdcmpeq",
        "__aeabi_cdcmple",
        "__aeabi_cdrcmple",
        "__aeabi_cfcmpeq",
        "__aeabi_cfcmple",
        "__aeabi_cfrcmple",
        "__aeabi_d2f",
        "__aeabi_d2iz",
        "__aeabi_d2lz",
        "__aeabi_d2uiz",
        "__aeabi_d2ulz",
        "__aeabi_dadd",
        "__aeabi_dcmpeq",
        "__aeabi_dcmpge",
        "__aeabi_dcmpgt",
        "__aeabi_dcmple",
        "__aeabi_dcmplt",
        "__aeabi_dcmpun",
        "__aeabi_ddiv",
        "__aeabi_dmul",
        "__aeabi_drsub",
        "__aeabi_dsub",
        "__aeabi_f2d",
        "__aeabi_f2iz",
        "__aeabi_f2lz",
        "__aeabi_f2uiz",
        "__aeabi_f2ulz",
        "__aeabi_fadd",
        "__aeabi_fcmpeq",
        "__aeabi_fcmpge",
        "__aeabi_fcmpgt",
        "__aeabi_fcmple",
        "__aeabi_fcmplt",
        "__aeabi_fcmpun",
        "__aeabi_fdiv",
        "__aeabi_fmul",
        "__aeabi_frsub",
        "__aeabi_fsub",
        "__aeabi_i2d",
        "__aeabi_i2f",
        "__aeabi_idiv",
        "__aeabi_idivmod",
        "__aeabi_l2d",
        "__aeabi_l2f",
        "__aeabi_ldivmod",
        "__aeabi_lmul",
        "__aeabi_memcpy",
        "__aeabi_memcpy4",
        "__aeabi_memcpy8",
        "__aeabi_memset",
        "__aeabi_memset4",
        "__aeabi_memset8",
        "__aeabi_ui2d",
        "__aeabi_ui2f",
        "__aeabi_uidiv",
        "__aeabi_uidivmod",
        "__aeabi_ul2d",
        "__aeabi_ul2f",
        "__aeabi_uldivmod",
        "__clz",
        "__clzdi2",
        "__clzl",
        "__clzll",
        "__clzsi2",
        "__ctzdi2",
        "__ctzsi2",
        "__popcountdi2",
        "__popcountsi2",
        "acos",
        "acosf",
        "acosh",
        "acoshf",
        "asin",
        "asinf",
        "asinh",
        "asinhf",
        "atan",
        "atan2",
        "atan2f",
        "atanf",
        "atanh",
        "atanhf",
        "calloc",
        "cbrt",
        "cbrtf",
        "ceil",
        "ceilf",
        "copysign",
        "copysignf",
        "cos",
        "cosf",
        "cosh",
        "coshf",
        "drem",
        "dremf",
        "exp",
        "exp10",
        "exp10f",
        "exp2",
        "exp2f",
        "expf",
        "expm1",
        "expm1f",
        "floor",
        "floorf",
        "fma",
        "fmaf",
        "fmod",
        "fmodf",
        "free",
        "getchar",
        "gnu",
        "hypot",
        "hypotf",
        "ldexp",
        "ldexpf",
        "log",
        "log10",
        "log10f",
        "log1p",
        "log1pf",
        "log2",
        "log2f",
        "logf",
        "malloc",
        "memcpy",
        "memset",
        "pow",
        "powf",
        "printf",
        "putchar",
        "puts",
        "remainder",
        "remainderf",
        "remquo",
        "remquof",
        "round",
        "roundf",
        "sin",
        "sinf",
        "sinh",
        "sinhf",
        "snprintf",
        "sprintf",
        "sqrt",
        "sqrtf",
        "tan",
        "tanf",
        "tanh",
        "tanhf",
        "trunc",
        "truncf",
        "vprintf",
        "vsnprintf",
]

def pico_binary(*, name, srcs, deps):
    native.genrule(
        name = name,
        srcs = [":{}.elf".format(name)],
        outs = ["{}.uf2".format(name)],
        cmd = "$(location @pico-sdk//:elf2uf2) $< $@",
        tools = ["@pico-sdk//:elf2uf2"],
    )


    native.cc_binary(
        name = "{}.elf".format(name),
        srcs = srcs + [
            "@pico-sdk//:bs2_default_padded_checksummed",
        ],
        linkopts = ["-Wl,--wrap={}".format(fn) for fn in WRAP_FUNCTIONS] + [
            "-mcpu=cortex-m0plus",
            "-mthumb",
            "--specs=nosys.specs",
            "-Wl,--gc-sections",
            "-Wl,--script=$(rootpath @pico-sdk//:src/rp2_common/pico_standard_link/memmap_default.ld)",
        ],
        target_compatible_with = [
            "@platforms//os:none",
            "@platforms//cpu:armv6-m",
        ],
        deps = deps + [
            "@pico-sdk//:src/rp2_common/pico_standard_link/memmap_default.ld",
        ],
    )

def _pico_binary_impl(ctx):
    cc_toolchain = find_cpp_toolchain(ctx)

    uf2 = ctx.actions.declare_file("{}.uf2".format(ctx.label.name))
    elf = ctx.actions.declare_file("{}.elf".format(ctx.label.name))

    ctx.actions.run(
        outputs = [uf2],
        inputs = [elf],
        arguments = [elf.basename, uf2.basename],
        progress_message = "Create UF2 file {}".format(uf2.short_path),
        executable = ctx.executable.elf2uf2,
    )

    native.cc_binary(
        name = elf.basename,
        srcs = ctx.attr.srcs + [
            "@pico-sdk//:bs2_default_padded_checksummed",
        ],
        linkopts = ["-Wl,--wrap={}".format(fn) for fn in WRAP_FUNCTIONS] + [
            "-mcpu=cortex-m0plus",
            "-mthumb",
            "--specs=nosys.specs",
            "-Wl,--gc-sections",
            "-Wl,--script=$(rootpath @pico-sdk//:src/rp2_common/pico_standard_link/memmap_default.ld)",
        ],
        target_compatible_with = [
            "@platforms//os:none",
            "@platforms//cpu:armv6-m",
        ],
        deps = ctx.attr.deps + [
            "@pico-sdk//:src/rp2_common/pico_standard_link/memmap_default.ld",
        ],
    )

    return [DefaultInfo(files = depset([uf2]))]

_pico_binary = rule(
    implementation = _pico_binary_impl,
    attrs = {
        "srcs": attr.label_list(
            mandatory = True,
            allow_empty = False,
            allow_files = True
        ),
        "deps": attr.label_list(
            mandatory = True,
            allow_empty = False,
        ),
        "elf2uf2": attr.label(
            executable = True,
            cfg = "exec",
            allow_files = True,
            default = Label("@pico-sdk//:elf2uf2"),
        )
    }
)
